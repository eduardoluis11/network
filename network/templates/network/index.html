{% extends "network/layout.html" %}

<!-- This "load static" removed the error message caused by the "static" keyword 
on the src attribute that calls the JS file (source: thedeleted account that replied 
to Carual's post:
https://www.reddit.com/r/django/comments/f12r0r/invalid_block_tag_on_line_17_static_did_you/ ) -->
{% load static %}

{% block body %}


    <!-- I will make the index.html file the “All Posts” page. -->
    <h1>All Posts</h1>

    <!-- I will add the csrf token. For that, I will add the <form> tags in the page that will let me create posts.
    However, the form itself will be created using Django forms. For that, I will create a file called forms.py, and
    create the form there.

    I will add the form for creating a post here in the “All Posts” page.

    I will only render the form for creating a post if the user’s logged in. I should add a “login required” decorator
    in the index.html file for the <form> tag (source: my "commerce" homework submission:
    https://github.com/me50/eduardoluis11/tree/web50/projects/2020/x/commerce .)

    I will use the "as_p" notation while calling the form so that the format looks good in different screen
    sizes.

    I will print a success message if the user creates a post.-->
    {% if user.is_authenticated %}
        <p style="color: green;">{{post_creation_success_message}}</p>

        <form method="post">
            {% csrf_token %}

            {{form.as_p}}   <!-- Django form -->

            <input class="btn btn-primary" type="submit" value="Post">  <!-- Submit button -->
        </form>
        <br>
    {% endif %}

    <!-- 	Remember that everyone should be able to see all posts, regardless of whether or not they are logged in.

	The href of the “All Posts” link on the navbar already has the value “{% url 'index' %}” in it. I don’t have to add
	the link to the “All Posts” navbar link.

	Now, I will at least show the posts in the “All Posts” page, without necessarily showing all the data from all
	the columns. I just want to make sure that I can display the posts on the main page.

	For that, I will have to display data using Jinja notation on the index.html file.

	I can show each of the columns for each post using Jinja notation. I can use “post.likes” or “post.username” to
	show each of the columns of each post.

	I will add a Bootstrap card or something similar to enclose each post in a rectangle shape. That will make it
	easier for users to distinguish each post. I will use the “card mb” class to create the Bootstrap card (source:
	https://getbootstrap.com/docs/4.4/components/card/ .) I will add a max-width to its CSS (using “rem” units) if it
	looks “ugly” on wide screens.

	I ended up using the red heart emoji as the icon that accompanies the like count. Source of the emoji code:
	https://emojipedia.org/red-heart/ .

	Now, I will add the link to the profile page to all instances of the username in the “all posts” page, as well as
	in the navbar. For the navbar, I will grab the username of the logged user. Meanwhile, for the username in the
	posts, I will use Jinja notation to get the username of that user from the Post table.

    If I'm not logged in, and if I didn't post that post, I shouldn't even be able to see the "Edit" link.

    After further consideration, I think that it’s just much easier to use Jinja notation to check if the author of a
    post is the logged user using only Jinja notation directly on the HTML files. Jinja stores the name of the logged
    user in the “user.username” variable.

    The above didn’t work. Instead, I will try sending the logged user’s username as a string via Jinja from the view.
    Then, I will try comparing it to the post’s author.

    To convert the database entry that contains the author of a post (in may case, “post.user”) into a string, I need
    to first use a Django filter called “stringformat” (source:
    https://docs.djangoproject.com/en/4.0/ref/templates/builtins/#filters .) That filter converts variables into
    strings. However, to do that, I need to specify a letter as a parameter to specify the kind of string that I want
    as a result. In my case, I want the letter “s”, since that’s the Python equivalent of using str() to convert
    something into a string (source: https://docs.python.org/3/library/stdtypes.html#old-string-formatting .) It needs
    to be a lower case “s”, or the variable will turn into an empty string (i.e.: ‘’.)

    I’ll make it a link, so I’ll add an <a> tag to the “Edit” word.

    I added 2 parameters as a margin to edit the vertical and horizontal margins separately (source:
    https://www.w3schools.com/css/css_margin.asp .)

    I will assign the div containing the body of the post a class instead of an ID since I'm rendering a ton of posts,
    and using multiple IDs with the same name could give me trouble. If using classes give me trouble with JS's fetch()
    function, I will change the div's class into an ID.

    I have an idea to fix the above issue: I will create an ID for the div that will contain the post’s body, but
    instead of hardcoding some name into the ID, I will use Jinja notation, and I will insert the ID of that post. That
    way, each post will have a different ID, and I will be able to access that ID via JS to edit that specific post.

    I will send via an onclick() event the post's ID number so that my JS code is able to edit that specific post.

    I won’t add code yet to the edit() view to indicate what happens if the user clicks on the “Save” button. Instead,
    I will create the “Save” button in the home page. This button will only be rendered after the user clicks on the
    “Edit” button.

    -->
    {% for post in paginated_posts_in_current_page %}
        <div class="card mb-3">
            <a href="profile/{{post.user}}"><b>{{post.user}}</b></a>

            <!-- This renders the "Edit" link if the logged user is the author of the post -->
            {% if user.is_authenticated %}

                <!-- DEBUG msg (source:
                https://stackoverflow.com/questions/46728372/invalid-block-tag-set-expected-empty-or-endfor-did-you-forget-to-registe) -->
<!--                {% with post_author=post.user|stringformat:"s" %}-->
<!--                    <b>{{post_author}}</b>-->
<!--                    <b>{{post.user}}</b>-->


                    <!-- DEBUG msg: This will print something if post.user is a string (source:
                    https://www.webforefront.com/django/usebuiltinjinjafilters.html ) -->
    <!--                {% if post_author is string %}-->
    <!--                    <b>post.user is a string</b>-->
    <!--                {% else %}-->
    <!--                    <b>Sorry. post.user is NOT a string</b>-->
    <!--                {% endif %}-->

                    <!-- This renders the "Edit" button if the logged user is the author of the post -->
                    {% if logged_user_string == post.user|stringformat:"s" %}
                        <div>
                            <button class="btn btn-primary" style="width: 80px; margin:10px 0px;" onclick="edit('{{post.id}}')">
                                Edit
                            </button>

                            <!-- This will render the "Save" button after the user clicks on "Edit" -->
                            <div id="save_button_{{post.id}}"></div>
                        </div>

                    {% endif %}

<!--                {% endwith %}-->

                <!-- DEBUG msg -->
<!--                <b>{{logged_user_string}}</b>-->
            {% endif %}

            <!-- Body of the post. -->
            <div id="{{post.id}}">
                <p>{{post.body}}</p>
            </div>


            <p>{{post.timestamp}}</p>
            <p>❤ {{post.number_of_likes}}</p>
            <br>
        </div>

    {% endfor %}

<!--    {{paginated_posts_in_current_page}}-->

    <br>
    <br>
    <!-- DEBUG code: This will let me test if React is working (source: 
    https://youtu.be/jrBhi8wbzPw  -->
    <div id="react-test"></div>



    <!-- DEBUG code: This will test if my code is actually detecting JS code -->
<!--    <script>-->
<!--        console.log("This JS code was executed directly into the index.html file.")-->
<!--    </script>-->

    <!-- To show the links to the “previous” and “next” pages on the footer of the pages with posts, I will use this
    to call the pagination.html template (https://testdriven.io/blog/django-pagination/ ).

    To make it work, I needed to add "network/" in front of "pagination.html".
    -->
	{% include "network/pagination.html" %}

    <!-- I will use vanilla JS, edit the post using the innerHTML property, and send the edition to the database using
    JSON. I’d rather forget about React for the time being for this question.

	So, to edit a specific post using JS, I will add an “onclick()” or “onsubmit” on each post using Jinja notation,
	and the argument of that event listener will be that post’s ID, which I can call by using “post.ID”. So, I may add
	something like “onclick(‘{{post.id}}’)” to the “Edit” link.

	I will modify the “Edit” link so that it becomes a button, so that it’s easier to handle with JS code.

    Now, whenever the user clicks on the “Edit button”, I will render a <textarea> tag. I can do that by using editing the 
    innerHTML attribute of the div that contains the ID of that specific post. I can get that <div> by using a 
    getElementByID selector.

    Now, I need to prepopulate the <textarea> that appears with the body of that post. I need to use an API and the fetch() 
    function for this. Or, to make things simpler, I could simply store the HTML of that div into a variable, and then 
    I could insert that variable into the <textarea> being rendered by the double ticks and the innerHTML attribute. To 
    sget the content of the post’s body, I can simply call innerHTML.

    I’m on the right track. However, I’m also getting the <p> tags of the body of that post, which I don’t want. I only want 
    the text inside those <p> tags. To get them, I will use textContent attribute from JS (source: 
    https://bobbyhadz.com/blog/javascript-get-text-of-paragraph .) I will use “variable_with_text.textContent” to get only 
    the text from the post’s body without getting the <p> tags.

    It’s working. Now, I’m getting extra space both before and after the text of the post. To remove it, I’ll try to use 
    the trim() function from JS (source: https://bobbyhadz.com/blog/javascript-get-text-of-paragraph .)

    I will add code so that the “edit” button makes the “Save” button appear.

    After further consideration, I realize that the fetch() function (if I manually specify it) will always send a POST 
    request, independently of whether I use a form or a button for the “Save” button. So, for the sake of simplicity, I 
    will use a <button> tag for the “Save” button.

    I will add a “onclick()” even listener to the “Save” button, which will obtain the ID of that post to differentiate 
    that post from other posts. Also, I will call the function that will fetch the API from the edit_post() view. But, 
    for that, I need to create that “save()” function beforehand.

    The full explanation of the save() function is given on the views.py file. But, in a nutshell, the save() function
    will call the edit_page() API via a fetch() call to store the edited post in the database. I also need the text
    of the edited post in the save() function. So, to get that, I will assign an ID number to the <textarea> generated
    by the edit() function. Then, I will get that <textarea> with that ID number with a document.getElementById() in
    the save() function and get the text from it.

    -->
    <script>

        /* This creates a cookie (source: anonymous's reply on
        https://stackoverflow.com/questions/43606056/proper-django-csrf-validation-using-fetch-post-request ). 
        
        This is needed to be able to have the CSRF protection activated without getting any bugs from fetch() calls. 
        
        */
        function getCookie(name) {
            var cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                var cookies = document.cookie.split(';');
                for (var i = 0; i < cookies.length; i++) {
                    var cookie = cookies[i].trim();
                    // Does this cookie string begin with the name we want?
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }




        /* This detects if the <textarea> text has been modified. 
        The solution will be to use the “oninput” JS event listener, which executes code each time a user types a letter on a 
        <textarea> field (source: https://www.w3schools.com/jsref/event_oninput.asp .) To use this, I will have to create a 
        3rd JS function, which will get the edited text from the <textarea> I could call it something like “edited_text(argument)”. 
        That function will be called on either the save() function, or it will be an independent function. Then, I 
        will call it from the save() function to get the edited text from the post. I will add the event listener to 
        the <textarea> code, which is generated on the edit() function. Finally, the save() function will send that 
        edited text from the JS code to the view. 

        I need the post's ID on the "oninput" function (edited_text()) as an argument, since I need to differentiate that post 
        from the other posts.

        What I can do is that, each time that the “oninput” even listener is called, that is, each time that the edit_text() function 
        is called, I will edit the HTML code of the <textarea> by using the innerHTML attribute. That way, the text will be constantly 
        be edited on the HTML. Then, when I click on “Save”, the edited text will be sent to the API. I could use code like this 
        (source: https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref_oninput ):
            let text = document.getElementById("id_of_textarea").value;
            document.getElementById("id_of_textarea").innerHTML = text;

            It should work with just using “=” in the snippet that ends with “innerHTML”. That is, it should work without using “+=”. In 
        other words, if I delete something from the existing text, and if I don’t add any additional text, it should still get all of 
        the text properly.

        BUG FIX: The above didn’t work properly, but that was because I'm also grabbing the "value" attribute. That is, I was doing 
        "code.value.innHTML", which could have caused a bug. So, I will make a new variable that will get the text 
        from the <textarea>, and replace it with what the user has typed so far by using a getElementByID, and then using
        "innerHTML".

        */
        function edited_text(post_id) {
            
            // DEBUG msg: This will execute each time that the user types anything in the <textarea>
            console.log(`You typed/deleted something from a <textarea> in the post with ID number ${post_id}.`);

            // This edits the text of the <textarea> in the HTML code whenever the user types something
            let text = document.getElementById(`textarea_${post_id}`).value;
            // text.innerHTML = text;

            // DEBUG msg: This is what the user has typed
            console.log(`You have written "${text}"`);

            // This replaces the HTML code from the <textarea> to include what the user has typed
            document.getElementById(`textarea_${post_id}`).innerHTML = text;

        }

        // Edit post mechanic
        function edit(post_id) {

            // DEBUG msg
            console.log(`This is post number ${post_id}`)

            // This gets the div with the post's body
            let post = document.getElementById(`${post_id}`)

            // This stores the text of the post's body
            let post_body = post.textContent.trim()

            // This renders the <textarea> tag that replaces the post's body
            post.innerHTML = `
            <textarea id="textarea_${post_id}" 
            oninput="edited_text(${post_id})">${post_body}</textarea>
            `

            // This stores the save button
            let save_button = document.getElementById(`save_button_${post_id}`)

            // This renders the "Save" button
            save_button.innerHTML = `
            <button class="btn btn-primary" onclick="save(${post_id})">Save</button>
            `

        }

        /* Function for saving edited posts 
        
        After saving the post, I will remove the <textarea>, and I will put the post's text between <p> tags, so that the post
        looks normal after clicking on the "Save" button. To do that, I need to edit the <div> that contains the <textarea>, 
        NOT the <textarea> itself.

        Now, I want to make the “Save” button to disappear after clicking on it.

        This is what I’ll do: I will use a huge code snippet to reate a cookie, and then insert it into the fetch() call to update 
        the post with the CSRF protection on (source: anonymous's reply on 
        https://stackoverflow.com/questions/43606056/proper-django-csrf-validation-using-fetch-post-request .) First, I will use 
        the getCookie() function made by anonymous in the previously mentioned link. Then, on the “save()” function, I will edit the 
        fetch() call to eliminate the “headers” attribute, and then specify the POST request and include the “credentials: same origin” 
        attribute into the fetch() call. I also need to create a variable that gets the cookie for the CSRF call.

        */
        function save(post_id) {

            // DEBUG msg
            console.log(`You have clicked "Save" on post number ${post_id}`)

            // This creates a cookie for the CSRF token
            let csrftoken = getCookie('csrftoken');

            // This gets the <textarea> with the edited text from the post
            let post = document.getElementById(`textarea_${post_id}`)

            // This stores the text of the post's body without spaces nor tags
            let post_body = post.textContent.trim()


            /* This will call the API to update the post in the database. I added an extra header to add
            a cookie to the fetch() call so that it doesn't give me problems while using CSRF protection.*/
            fetch(`/edit/${post_id}`, {
                method: 'POST',
                headers: {
                    "X-CSRFToken": csrftoken,
                    'Accept': 'application/json, text/plain, */*',
                    'Content-type':'application/json'
                },
                body:JSON.stringify({body:post_body, post_id:post_id})                
            })

            // This gets the div with the post's body
            let post_div = document.getElementById(`${post_id}`)

            // This transforms the <textarea> tags into <p> tags
            post_div.innerHTML = `
            <p>${post_body}</p>
            `

            // This stores the save button's div
            let save_button = document.getElementById(`save_button_${post_id}`)

            // This eliminates the "Save" button
            save_button.innerHTML = ''
        }

        
    </script>
{% endblock %}

<!-- This will call the .js file, which contains all the JS code. Source:
https://cs50.harvard.edu/web/2020/projects/3/mail/ . 

I will add the "babel" attribute to it so that the browser is able to interpret 
the React code (source: https://youtu.be/jrBhi8wbzPw .) -->
<!-- {% block script %}
    <script src="{% static 'network/network_script.js' %}"></script>
{% endblock %} -->

    <!-- To show the links to the “previous” and “next” pages on the footer of the pages with posts, I will use this
    to call the pagination.html template (https://testdriven.io/blog/django-pagination/ ):
    -->
<!--	{% include "pagination.html" %}-->